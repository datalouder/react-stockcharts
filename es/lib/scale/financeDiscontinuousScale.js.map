{"version":3,"sources":["../../../../src/lib/scale/financeDiscontinuousScale.js"],"names":["set","map","ascending","scaleLinear","isDefined","isNotDefined","head","last","levelDefinition","MAX_LEVEL","length","financeDiscontinuousScale","index","futureProvider","backingLinearScale","Error","scale","x","invert","inverted","Math","round","domain","arguments","range","rangeRound","clamp","interpolate","ticks","m","flexTicks","backingTicks","ticksMap","domainStart","domainEnd","start","max","ceil","abs","end","min","floor","desiredTickCount","i","ticksAtLevel","get","temp","slice","j","level","push","unsortedTicks","concat","d","sort","ticksSet","distance","remove","tickValues","values","parseInt","tickFormat","format","date","value","nice","copy"],"mappings":"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","file":"financeDiscontinuousScale.js","sourcesContent":["import { set, map } from 'd3-collection';\nimport { ascending } from 'd3-array';\nimport { scaleLinear } from 'd3-scale';\n\nimport { isDefined, isNotDefined, head, last } from '../utils';\nimport { levelDefinition } from './levels';\n\nconst MAX_LEVEL = levelDefinition.length - 1;\n\nexport default function financeDiscontinuousScale(\n  index,\n  futureProvider,\n  backingLinearScale = scaleLinear()\n) {\n  if (isNotDefined(index))\n    throw new Error(\n      'Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale'\n    );\n\n  function scale(x) {\n    return backingLinearScale(x);\n  }\n  scale.invert = function (x) {\n    const inverted = backingLinearScale.invert(x);\n    return Math.round(inverted * 10000) / 10000;\n  };\n  scale.domain = function (x) {\n    if (!arguments.length) return backingLinearScale.domain();\n    backingLinearScale.domain(x);\n    return scale;\n  };\n  scale.range = function (x) {\n    if (!arguments.length) return backingLinearScale.range();\n    backingLinearScale.range(x);\n    return scale;\n  };\n  scale.rangeRound = function (x) {\n    return backingLinearScale.range(x);\n  };\n  scale.clamp = function (x) {\n    if (!arguments.length) return backingLinearScale.clamp();\n    backingLinearScale.clamp(x);\n    return scale;\n  };\n  scale.interpolate = function (x) {\n    if (!arguments.length) return backingLinearScale.interpolate();\n    backingLinearScale.interpolate(x);\n    return scale;\n  };\n  scale.ticks = function (m, flexTicks) {\n    const backingTicks = backingLinearScale.ticks(m);\n    const ticksMap = map();\n\n    const [domainStart, domainEnd] = backingLinearScale.domain();\n\n    const start =\n      Math.max(Math.ceil(domainStart), head(index).index) +\n      Math.abs(head(index).index);\n    const end =\n      Math.min(Math.floor(domainEnd), last(index).index) +\n      Math.abs(head(index).index);\n\n    if (Math.floor(domainEnd) > end) {\n      // console.log(end, domainEnd, index);\n    }\n\n    const desiredTickCount = Math.ceil(\n      ((end - start) / (domainEnd - domainStart)) * backingTicks.length\n    );\n\n    for (let i = MAX_LEVEL; i >= 0; i--) {\n      const ticksAtLevel = ticksMap.get(i);\n      const temp = isNotDefined(ticksAtLevel) ? [] : ticksAtLevel.slice();\n\n      for (let j = start; j <= end; j++) {\n        if (index[j].level === i) {\n          temp.push(index[j]);\n        }\n      }\n\n      ticksMap.set(i, temp);\n    }\n\n    let unsortedTicks = [];\n    for (let i = MAX_LEVEL; i >= 0; i--) {\n      if (\n        ticksMap.get(i).length + unsortedTicks.length >\n        desiredTickCount * 1.5\n      )\n        break;\n      unsortedTicks = unsortedTicks.concat(ticksMap.get(i).map(d => d.index));\n    }\n\n    const ticks = unsortedTicks.sort(ascending);\n\n    // console.log(backingTicks.length, desiredTickCount, ticks, ticksMap);\n\n    if (!flexTicks && end - start > ticks.length) {\n      const ticksSet = set(ticks);\n\n      const d = Math.abs(head(index).index);\n\n      // ignore ticks within this distance\n      const distance = Math.ceil(\n        (backingTicks.length > 0\n          ? (last(backingTicks) - head(backingTicks)) / backingTicks.length / 4\n          : 1) * 1.5\n      );\n\n      for (let i = 0; i < ticks.length - 1; i++) {\n        for (let j = i + 1; j < ticks.length; j++) {\n          if (ticks[j] - ticks[i] <= distance) {\n            ticksSet.remove(\n              index[ticks[i] + d].level >= index[ticks[j] + d].level\n                ? ticks[j]\n                : ticks[i]\n            );\n          }\n        }\n      }\n\n      const tickValues = ticksSet.values().map(d => parseInt(d, 10));\n\n      // console.log(ticks.length, tickValues, level);\n      // console.log(ticks, tickValues, distance);\n\n      return tickValues;\n    }\n\n    return ticks;\n  };\n  scale.tickFormat = function () {\n    return function (x) {\n      const d = Math.abs(head(index).index);\n      const { format, date } = index[Math.floor(x + d)];\n      return format(date);\n    };\n  };\n  scale.value = function (x) {\n    const d = Math.abs(head(index).index);\n    if (isDefined(index[Math.floor(x + d)])) {\n      const { date } = index[Math.floor(x + d)];\n      return date;\n    }\n  };\n  scale.nice = function (m) {\n    backingLinearScale.nice(m);\n    return scale;\n  };\n  scale.index = function (x) {\n    if (!arguments.length) return index;\n    index = x;\n    return scale;\n  };\n  scale.copy = function () {\n    return financeDiscontinuousScale(\n      index,\n      futureProvider,\n      backingLinearScale.copy()\n    );\n  };\n  return scale;\n}\n"]}