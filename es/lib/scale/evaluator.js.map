{"version":3,"sources":["../../../../src/lib/scale/evaluator.js"],"names":["head","last","getClosestItemIndexes","isDefined","isNotDefined","getLogger","log","getNewEnd","fallbackEnd","xAccessor","initialXScale","start","lastItem","lastItemX","lastItemXValue","range","rangeStart","rangeEnd","newEnd","extentsWrapper","useWholeData","clamp","pointsPerPxThreshold","minPointsPerPxThreshold","flipXScale","filterData","data","inputDomain","currentPlotData","currentDomain","fallbackStart","plotData","domain","left","right","clampedDomain","filteredData","getFilteredResponse","length","Math","max","min","realInputDomain","xScale","copy","width","floor","chartWidth","showMaxThreshold","canShowTheseManyPeriods","newXScale","newWidth","slice","showMax","arrayLength","maxThreshold","minThreshold","showMinThreshold","threshold","ceil","newLeftIndex","newRightIndex","invert"],"mappings":"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","file":"evaluator.js","sourcesContent":["import {\n  head,\n  last,\n  getClosestItemIndexes,\n  isDefined,\n  isNotDefined,\n  getLogger,\n} from '../utils';\n\nconst log = getLogger('evaluator');\n\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n  const { lastItem, lastItemX } = fallbackEnd;\n  const lastItemXValue = xAccessor(lastItem);\n  const [rangeStart, rangeEnd] = initialXScale.range();\n\n  const newEnd =\n    ((rangeEnd - rangeStart) / (lastItemX - rangeStart)) *\n      (lastItemXValue - start) +\n    start;\n  return newEnd;\n}\n\nfunction extentsWrapper(\n  useWholeData,\n  clamp,\n  pointsPerPxThreshold,\n  minPointsPerPxThreshold,\n  flipXScale\n) {\n  function filterData(\n    data,\n    inputDomain,\n    xAccessor,\n    initialXScale,\n    { currentPlotData, currentDomain, fallbackStart, fallbackEnd } = {}\n  ) {\n    if (useWholeData) {\n      return { plotData: data, domain: inputDomain };\n    }\n\n    let left = head(inputDomain);\n    let right = last(inputDomain);\n    let clampedDomain = inputDomain;\n\n    let filteredData = getFilteredResponse(data, left, right, xAccessor);\n\n    if (filteredData.length === 1 && isDefined(fallbackStart)) {\n      left = fallbackStart;\n      right = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n\n      clampedDomain = [left, right];\n      filteredData = getFilteredResponse(data, left, right, xAccessor);\n    }\n\n    if (typeof clamp === 'function') {\n      clampedDomain = clamp(clampedDomain, [\n        xAccessor(head(data)),\n        xAccessor(last(data)),\n      ]);\n    } else {\n      if (clamp === 'left' || clamp === 'both' || clamp === true) {\n        clampedDomain = [\n          Math.max(left, xAccessor(head(data))),\n          clampedDomain[1],\n        ];\n      }\n\n      if (clamp === 'right' || clamp === 'both' || clamp === true) {\n        clampedDomain = [\n          clampedDomain[0],\n          Math.min(right, xAccessor(last(data))),\n        ];\n      }\n    }\n\n    if (clampedDomain !== inputDomain) {\n      filteredData = getFilteredResponse(\n        data,\n        clampedDomain[0],\n        clampedDomain[1],\n        xAccessor\n      );\n    }\n\n    const realInputDomain = clampedDomain;\n    // [xAccessor(head(filteredData)), xAccessor(last(filteredData))];\n\n    const xScale = initialXScale.copy().domain(realInputDomain);\n\n    let width = Math.floor(\n      xScale(xAccessor(last(filteredData))) -\n        xScale(xAccessor(head(filteredData)))\n    );\n\n    // prevent negative width when flipXScale\n    if (flipXScale && width < 0) {\n      width = width * -1;\n    }\n\n    let plotData, domain;\n\n    const chartWidth = last(xScale.range()) - head(xScale.range());\n\n    log(\n      `Trying to show ${filteredData.length} points in ${width}px,` +\n        ` I can show up to ${\n          showMaxThreshold(width, pointsPerPxThreshold) - 1\n        } points in that width. ` +\n        `Also FYI the entire chart width is ${chartWidth}px and pointsPerPxThreshold is ${pointsPerPxThreshold}`\n    );\n\n    if (\n      canShowTheseManyPeriods(\n        width,\n        filteredData.length,\n        pointsPerPxThreshold,\n        minPointsPerPxThreshold\n      )\n    ) {\n      plotData = filteredData;\n      domain = realInputDomain;\n      log('AND IT WORKED');\n    } else {\n      if (\n        chartWidth > showMaxThreshold(width, pointsPerPxThreshold) &&\n        isDefined(fallbackEnd)\n      ) {\n        plotData = filteredData;\n        const newEnd = getNewEnd(\n          fallbackEnd,\n          xAccessor,\n          initialXScale,\n          head(realInputDomain)\n        );\n        domain = [head(realInputDomain), newEnd];\n        // plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        // domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n        const newXScale = xScale.copy().domain(domain);\n        const newWidth = Math.floor(\n          newXScale(xAccessor(last(plotData))) -\n            newXScale(xAccessor(head(plotData)))\n        );\n\n        log(\n          `and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`\n        );\n      } else {\n        plotData =\n          currentPlotData ||\n          filteredData.slice(\n            filteredData.length - showMax(width, pointsPerPxThreshold)\n          );\n        domain = currentDomain || [\n          xAccessor(head(plotData)),\n          xAccessor(last(plotData)),\n        ];\n\n        const newXScale = xScale.copy().domain(domain);\n        const newWidth = Math.floor(\n          newXScale(xAccessor(last(plotData))) -\n            newXScale(xAccessor(head(plotData)))\n        );\n\n        log(\n          `and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`\n        );\n      }\n    }\n    return { plotData, domain };\n  }\n  return { filterData };\n}\n\nfunction canShowTheseManyPeriods(\n  width,\n  arrayLength,\n  maxThreshold,\n  minThreshold\n) {\n  return (\n    arrayLength > showMinThreshold(width, minThreshold) &&\n    arrayLength < showMaxThreshold(width, maxThreshold)\n  );\n}\n\nfunction showMinThreshold(width, threshold) {\n  return Math.max(1, Math.ceil(width * threshold));\n}\n\nfunction showMaxThreshold(width, threshold) {\n  return Math.floor(width * threshold);\n}\n\nfunction showMax(width, threshold) {\n  return Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\n\nfunction getFilteredResponse(data, left, right, xAccessor) {\n  const newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;\n  const newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;\n\n  const filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n  // console.log(right, newRightIndex, dataForInterval.length);\n\n  return filteredData;\n}\n\nexport default function ({\n  xScale,\n  useWholeData,\n  clamp,\n  pointsPerPxThreshold,\n  minPointsPerPxThreshold,\n  flipXScale,\n}) {\n  return extentsWrapper(\n    useWholeData || isNotDefined(xScale.invert),\n    clamp,\n    pointsPerPxThreshold,\n    minPointsPerPxThreshold,\n    flipXScale\n  );\n}\n"]}