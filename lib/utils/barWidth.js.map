{"version":3,"sources":["../../../src/lib/utils/barWidth.js"],"names":["plotDataLengthBarWidth","timeIntervalBarWidth","props","moreProps","widthRatio","xScale","range","l","r","totalWidth","Math","abs","invert","domain","dl","dr","width","length","interval","xAccessor","plotData","first","offset"],"mappings":";;;;;;;;QASgBA,sB,GAAAA,sB;QAsBAC,oB,GAAAA,oB;;AA/BhB;;AAEA;;;;;;;AAOO,SAASD,sBAAT,CAAgCE,KAAhC,EAAuCC,SAAvC,EAAkD;AAAA,MAC/CC,UAD+C,GAChCF,KADgC,CAC/CE,UAD+C;AAAA,MAE/CC,MAF+C,GAEpCF,SAFoC,CAE/CE,MAF+C;;AAAA,sBAIxCA,OAAOC,KAAP,EAJwC;AAAA;AAAA,MAIhDC,CAJgD;AAAA,MAI7CC,CAJ6C;;AAMvD,MAAMC,aAAaC,KAAKC,GAAL,CAASH,IAAID,CAAb,CAAnB;AACA,MAAIF,OAAOO,MAAP,IAAiB,IAArB,EAA2B;AAAA,yBACRP,OAAOQ,MAAP,EADQ;AAAA;AAAA,QAClBC,EADkB;AAAA,QACdC,EADc;;AAEzB,QAAMC,QAAQP,aAAaC,KAAKC,GAAL,CAASG,KAAKC,EAAd,CAA3B;AACA,WAAOC,QAAQZ,UAAf;AACD,GAJD,MAIO;AACL,QAAMY,SAAQP,aAAaJ,OAAOQ,MAAP,GAAgBI,MAA3C;AACA,WAAOD,SAAQZ,UAAf;AACD;AACF;;AAED;;;;;AAKO,SAASH,oBAAT,CAA8BiB,QAA9B,EAAwC;AAC7C,SAAO,UAAUhB,KAAV,EAAiBC,SAAjB,EAA4B;AAAA,QACzBC,UADyB,GACVF,KADU,CACzBE,UADyB;AAAA,QAEzBC,MAFyB,GAEOF,SAFP,CAEzBE,MAFyB;AAAA,QAEjBc,SAFiB,GAEOhB,SAFP,CAEjBgB,SAFiB;AAAA,QAENC,QAFM,GAEOjB,SAFP,CAENiB,QAFM;;;AAIjC,QAAMC,QAAQF,UAAU,iBAAKC,QAAL,CAAV,CAAd;AACA,WACEV,KAAKC,GAAL,CAASN,OAAOa,SAASI,MAAT,CAAgBD,KAAhB,EAAuB,CAAvB,CAAP,IAAoChB,OAAOgB,KAAP,CAA7C,IAA8DjB,UADhE;AAGD,GARD;AASD","file":"barWidth.js","sourcesContent":["import { head } from '../utils';\n\n/**\n * Bar width is based on the amount of items in the plot data and the distance between the first and last of those\n * items.\n * @param props the props passed to the series.\n * @param moreProps an object holding the xScale, xAccessor and plotData.\n * @return {number} the bar width.\n */\nexport function plotDataLengthBarWidth(props, moreProps) {\n  const { widthRatio } = props;\n  const { xScale } = moreProps;\n\n  const [l, r] = xScale.range();\n\n  const totalWidth = Math.abs(r - l);\n  if (xScale.invert != null) {\n    const [dl, dr] = xScale.domain();\n    const width = totalWidth / Math.abs(dl - dr);\n    return width * widthRatio;\n  } else {\n    const width = totalWidth / xScale.domain().length;\n    return width * widthRatio;\n  }\n}\n\n/**\n * Generates a width function that calculates the bar width based on the given time interval.\n * @param interval a d3-time time interval.\n * @return {Function} the width function.\n */\nexport function timeIntervalBarWidth(interval) {\n  return function (props, moreProps) {\n    const { widthRatio } = props;\n    const { xScale, xAccessor, plotData } = moreProps;\n\n    const first = xAccessor(head(plotData));\n    return (\n      Math.abs(xScale(interval.offset(first, 1)) - xScale(first)) * widthRatio\n    );\n  };\n}\n"]}