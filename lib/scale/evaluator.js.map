{"version":3,"sources":["../../../src/lib/scale/evaluator.js"],"names":["xScale","useWholeData","clamp","pointsPerPxThreshold","minPointsPerPxThreshold","flipXScale","extentsWrapper","invert","log","getNewEnd","fallbackEnd","xAccessor","initialXScale","start","lastItem","lastItemX","lastItemXValue","range","rangeStart","rangeEnd","newEnd","filterData","data","inputDomain","currentPlotData","currentDomain","fallbackStart","plotData","domain","left","right","clampedDomain","filteredData","getFilteredResponse","length","Math","max","min","realInputDomain","copy","width","floor","chartWidth","showMaxThreshold","canShowTheseManyPeriods","newXScale","newWidth","slice","showMax","arrayLength","maxThreshold","minThreshold","showMinThreshold","threshold","ceil","newLeftIndex","newRightIndex"],"mappings":"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","file":"evaluator.js","sourcesContent":["import {\n  head,\n  last,\n  getClosestItemIndexes,\n  isDefined,\n  isNotDefined,\n  getLogger,\n} from '../utils';\n\nconst log = getLogger('evaluator');\n\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n  const { lastItem, lastItemX } = fallbackEnd;\n  const lastItemXValue = xAccessor(lastItem);\n  const [rangeStart, rangeEnd] = initialXScale.range();\n\n  const newEnd =\n    ((rangeEnd - rangeStart) / (lastItemX - rangeStart)) *\n      (lastItemXValue - start) +\n    start;\n  return newEnd;\n}\n\nfunction extentsWrapper(\n  useWholeData,\n  clamp,\n  pointsPerPxThreshold,\n  minPointsPerPxThreshold,\n  flipXScale\n) {\n  function filterData(\n    data,\n    inputDomain,\n    xAccessor,\n    initialXScale,\n    { currentPlotData, currentDomain, fallbackStart, fallbackEnd } = {}\n  ) {\n    if (useWholeData) {\n      return { plotData: data, domain: inputDomain };\n    }\n\n    let left = head(inputDomain);\n    let right = last(inputDomain);\n    let clampedDomain = inputDomain;\n\n    let filteredData = getFilteredResponse(data, left, right, xAccessor);\n\n    if (filteredData.length === 1 && isDefined(fallbackStart)) {\n      left = fallbackStart;\n      right = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n\n      clampedDomain = [left, right];\n      filteredData = getFilteredResponse(data, left, right, xAccessor);\n    }\n\n    if (typeof clamp === 'function') {\n      clampedDomain = clamp(clampedDomain, [\n        xAccessor(head(data)),\n        xAccessor(last(data)),\n      ]);\n    } else {\n      if (clamp === 'left' || clamp === 'both' || clamp === true) {\n        clampedDomain = [\n          Math.max(left, xAccessor(head(data))),\n          clampedDomain[1],\n        ];\n      }\n\n      if (clamp === 'right' || clamp === 'both' || clamp === true) {\n        clampedDomain = [\n          clampedDomain[0],\n          Math.min(right, xAccessor(last(data))),\n        ];\n      }\n    }\n\n    if (clampedDomain !== inputDomain) {\n      filteredData = getFilteredResponse(\n        data,\n        clampedDomain[0],\n        clampedDomain[1],\n        xAccessor\n      );\n    }\n\n    const realInputDomain = clampedDomain;\n    // [xAccessor(head(filteredData)), xAccessor(last(filteredData))];\n\n    const xScale = initialXScale.copy().domain(realInputDomain);\n\n    let width = Math.floor(\n      xScale(xAccessor(last(filteredData))) -\n        xScale(xAccessor(head(filteredData)))\n    );\n\n    // prevent negative width when flipXScale\n    if (flipXScale && width < 0) {\n      width = width * -1;\n    }\n\n    let plotData, domain;\n\n    const chartWidth = last(xScale.range()) - head(xScale.range());\n\n    log(\n      `Trying to show ${filteredData.length} points in ${width}px,` +\n        ` I can show up to ${\n          showMaxThreshold(width, pointsPerPxThreshold) - 1\n        } points in that width. ` +\n        `Also FYI the entire chart width is ${chartWidth}px and pointsPerPxThreshold is ${pointsPerPxThreshold}`\n    );\n\n    if (\n      canShowTheseManyPeriods(\n        width,\n        filteredData.length,\n        pointsPerPxThreshold,\n        minPointsPerPxThreshold\n      )\n    ) {\n      plotData = filteredData;\n      domain = realInputDomain;\n      log('AND IT WORKED');\n    } else {\n      if (\n        chartWidth > showMaxThreshold(width, pointsPerPxThreshold) &&\n        isDefined(fallbackEnd)\n      ) {\n        plotData = filteredData;\n        const newEnd = getNewEnd(\n          fallbackEnd,\n          xAccessor,\n          initialXScale,\n          head(realInputDomain)\n        );\n        domain = [head(realInputDomain), newEnd];\n        // plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        // domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n        const newXScale = xScale.copy().domain(domain);\n        const newWidth = Math.floor(\n          newXScale(xAccessor(last(plotData))) -\n            newXScale(xAccessor(head(plotData)))\n        );\n\n        log(\n          `and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`\n        );\n      } else {\n        plotData =\n          currentPlotData ||\n          filteredData.slice(\n            filteredData.length - showMax(width, pointsPerPxThreshold)\n          );\n        domain = currentDomain || [\n          xAccessor(head(plotData)),\n          xAccessor(last(plotData)),\n        ];\n\n        const newXScale = xScale.copy().domain(domain);\n        const newWidth = Math.floor(\n          newXScale(xAccessor(last(plotData))) -\n            newXScale(xAccessor(head(plotData)))\n        );\n\n        log(\n          `and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`\n        );\n      }\n    }\n    return { plotData, domain };\n  }\n  return { filterData };\n}\n\nfunction canShowTheseManyPeriods(\n  width,\n  arrayLength,\n  maxThreshold,\n  minThreshold\n) {\n  return (\n    arrayLength > showMinThreshold(width, minThreshold) &&\n    arrayLength < showMaxThreshold(width, maxThreshold)\n  );\n}\n\nfunction showMinThreshold(width, threshold) {\n  return Math.max(1, Math.ceil(width * threshold));\n}\n\nfunction showMaxThreshold(width, threshold) {\n  return Math.floor(width * threshold);\n}\n\nfunction showMax(width, threshold) {\n  return Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\n\nfunction getFilteredResponse(data, left, right, xAccessor) {\n  const newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;\n  const newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;\n\n  const filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n  // console.log(right, newRightIndex, dataForInterval.length);\n\n  return filteredData;\n}\n\nexport default function ({\n  xScale,\n  useWholeData,\n  clamp,\n  pointsPerPxThreshold,\n  minPointsPerPxThreshold,\n  flipXScale,\n}) {\n  return extentsWrapper(\n    useWholeData || isNotDefined(xScale.invert),\n    clamp,\n    pointsPerPxThreshold,\n    minPointsPerPxThreshold,\n    flipXScale\n  );\n}\n"]}