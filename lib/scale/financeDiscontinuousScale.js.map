{"version":3,"sources":["../../../src/lib/scale/financeDiscontinuousScale.js"],"names":["financeDiscontinuousScale","MAX_LEVEL","levelDefinition","length","index","futureProvider","backingLinearScale","Error","scale","x","invert","inverted","Math","round","domain","arguments","range","rangeRound","clamp","interpolate","ticks","m","flexTicks","backingTicks","ticksMap","domainStart","domainEnd","start","max","ceil","abs","end","min","floor","desiredTickCount","i","ticksAtLevel","get","temp","slice","j","level","push","set","unsortedTicks","concat","map","d","sort","ascending","ticksSet","distance","remove","tickValues","values","parseInt","tickFormat","format","date","value","nice","copy"],"mappings":"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","file":"financeDiscontinuousScale.js","sourcesContent":["import { set, map } from 'd3-collection';\nimport { ascending } from 'd3-array';\nimport { scaleLinear } from 'd3-scale';\n\nimport { isDefined, isNotDefined, head, last } from '../utils';\nimport { levelDefinition } from './levels';\n\nconst MAX_LEVEL = levelDefinition.length - 1;\n\nexport default function financeDiscontinuousScale(\n  index,\n  futureProvider,\n  backingLinearScale = scaleLinear()\n) {\n  if (isNotDefined(index))\n    throw new Error(\n      'Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale'\n    );\n\n  function scale(x) {\n    return backingLinearScale(x);\n  }\n  scale.invert = function (x) {\n    const inverted = backingLinearScale.invert(x);\n    return Math.round(inverted * 10000) / 10000;\n  };\n  scale.domain = function (x) {\n    if (!arguments.length) return backingLinearScale.domain();\n    backingLinearScale.domain(x);\n    return scale;\n  };\n  scale.range = function (x) {\n    if (!arguments.length) return backingLinearScale.range();\n    backingLinearScale.range(x);\n    return scale;\n  };\n  scale.rangeRound = function (x) {\n    return backingLinearScale.range(x);\n  };\n  scale.clamp = function (x) {\n    if (!arguments.length) return backingLinearScale.clamp();\n    backingLinearScale.clamp(x);\n    return scale;\n  };\n  scale.interpolate = function (x) {\n    if (!arguments.length) return backingLinearScale.interpolate();\n    backingLinearScale.interpolate(x);\n    return scale;\n  };\n  scale.ticks = function (m, flexTicks) {\n    const backingTicks = backingLinearScale.ticks(m);\n    const ticksMap = map();\n\n    const [domainStart, domainEnd] = backingLinearScale.domain();\n\n    const start =\n      Math.max(Math.ceil(domainStart), head(index).index) +\n      Math.abs(head(index).index);\n    const end =\n      Math.min(Math.floor(domainEnd), last(index).index) +\n      Math.abs(head(index).index);\n\n    if (Math.floor(domainEnd) > end) {\n      // console.log(end, domainEnd, index);\n    }\n\n    const desiredTickCount = Math.ceil(\n      ((end - start) / (domainEnd - domainStart)) * backingTicks.length\n    );\n\n    for (let i = MAX_LEVEL; i >= 0; i--) {\n      const ticksAtLevel = ticksMap.get(i);\n      const temp = isNotDefined(ticksAtLevel) ? [] : ticksAtLevel.slice();\n\n      for (let j = start; j <= end; j++) {\n        if (index[j].level === i) {\n          temp.push(index[j]);\n        }\n      }\n\n      ticksMap.set(i, temp);\n    }\n\n    let unsortedTicks = [];\n    for (let i = MAX_LEVEL; i >= 0; i--) {\n      if (\n        ticksMap.get(i).length + unsortedTicks.length >\n        desiredTickCount * 1.5\n      )\n        break;\n      unsortedTicks = unsortedTicks.concat(ticksMap.get(i).map(d => d.index));\n    }\n\n    const ticks = unsortedTicks.sort(ascending);\n\n    // console.log(backingTicks.length, desiredTickCount, ticks, ticksMap);\n\n    if (!flexTicks && end - start > ticks.length) {\n      const ticksSet = set(ticks);\n\n      const d = Math.abs(head(index).index);\n\n      // ignore ticks within this distance\n      const distance = Math.ceil(\n        (backingTicks.length > 0\n          ? (last(backingTicks) - head(backingTicks)) / backingTicks.length / 4\n          : 1) * 1.5\n      );\n\n      for (let i = 0; i < ticks.length - 1; i++) {\n        for (let j = i + 1; j < ticks.length; j++) {\n          if (ticks[j] - ticks[i] <= distance) {\n            ticksSet.remove(\n              index[ticks[i] + d].level >= index[ticks[j] + d].level\n                ? ticks[j]\n                : ticks[i]\n            );\n          }\n        }\n      }\n\n      const tickValues = ticksSet.values().map(d => parseInt(d, 10));\n\n      // console.log(ticks.length, tickValues, level);\n      // console.log(ticks, tickValues, distance);\n\n      return tickValues;\n    }\n\n    return ticks;\n  };\n  scale.tickFormat = function () {\n    return function (x) {\n      const d = Math.abs(head(index).index);\n      const { format, date } = index[Math.floor(x + d)];\n      return format(date);\n    };\n  };\n  scale.value = function (x) {\n    const d = Math.abs(head(index).index);\n    if (isDefined(index[Math.floor(x + d)])) {\n      const { date } = index[Math.floor(x + d)];\n      return date;\n    }\n  };\n  scale.nice = function (m) {\n    backingLinearScale.nice(m);\n    return scale;\n  };\n  scale.index = function (x) {\n    if (!arguments.length) return index;\n    index = x;\n    return scale;\n  };\n  scale.copy = function () {\n    return financeDiscontinuousScale(\n      index,\n      futureProvider,\n      backingLinearScale.copy()\n    );\n  };\n  return scale;\n}\n"]}